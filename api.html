
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>inmembrane</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 20px;
        padding-bottom: 40px;
      }

      /* Custom container */
      .container-narrow {
        margin: 0 auto;
        max-width: 700px;
      }
      .container-narrow > hr {
        margin: 30px 0;
      }

      /* Main marketing message and sign up button */
      .jumbotron {
        margin: 60px 0;
        text-align: center;
      }
      .jumbotron h1 {
        font-size: 72px;
        line-height: 1;
      }
      .jumbotron .btn {
        font-size: 21px;
        padding: 14px 24px;
      }

      /* Supporting marketing content */
      .marketing {
        margin: 60px 0;
      }
      .marketing p + h4 {
        margin-top: 28px;
      }
    </style>
    <link href="css/bootstrap-responsive.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="shortcut icon" href="ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <a href="https://github.com/boscoh/inmembrane"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

    <div class="container-narrow">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="index.html">Home</a></li>
          <li><a href="customization.html">Configuration</a></li>
          <li class="active"><a href="#">API</a></li>
        </ul>
        <h3 class="muted">inmembrane</h3>
      </div>

      <hr>


      <div class="row-fluid marketing">
        <div class="span12">

          
<h1>Program structure and APIs</h1>
<p>The high-level structure of <em>inmembrane</em> consists of:
</p>
<ul>
 <li>
     <code>inmembrane_scan</code> -- handles commandline options and calls inmembrane.process(params) to run the workflow (or runs unit tests)
 </li>

 <li>
     <code>inmembrane/__init__.py</code> -- a wrapper to manage configuration parameters, high-level file input and output, and execution of the specified protocol 
 </li>

 <li>
     <code>inmembrane/helpers.py</code> -- various helper functions that are used throughout the program
 </li>

 <li>
     <code>inmembrane/protocols</code> -- a module that contains protocol handlers (eg gram_pos, gram_neg). These contain the business logic of which analyses to perform (via plugins) and the rules of how to label or classify sequences based on the plugin output (eg, <em>if not is</em>signalp, label with CYTOPLASM_).
 </li>

 <li>
     <code>inmembrane/plugins</code> -- individual plugins for each external analysis tool. These handle the local execution (or HTTP request), parsing of output and population of labels on a sequence within the <code>proteins</code> datastructure.
 </li>
</ul>

<h3>The main loop and data structure</h3>
<p>At it's core, <em>inmembrane</em>'s task is to label ('annotate') a set of protein sequences stored within the <code>proteins</code> data structure.
</p>
<p>The <code>proteins</code> data structure is a dictionary where the keys are the <em>seqid</em> (sequence ID) of the protein, and the value is itself a dictionary of key-value pairs.
</p>
<p>The program first reads a FASTA file to set up the dictionary, where at first only the 'sequence' field is created (using <code>helpers.create_proteins_dict()</code>, called from <code>inmembrane/__init__.py</code>). The <code>proteins</code> data structure is then passed to each plugin specified in the protocol, and progressively filled with properties generated by the plugin. 
</p>
<p>Each plugin interfaces with an external analysis tool, whether through a local execution of a binary or via a web-based API.
</p>
<p>Here is an example of a <code>proteins</code> dictionary for two sequences with <em>seqid</em>'s SPy_1392 and SPy_1379 after running a protocol to annotate them with key-value pairs (amino acid sequences shortened with '....' for clarity).
</p>
<pre><code>{
'SPy_1392': {'lipop_cleave_position': None, 'category': 'MEMBRANE(non-PSE)', 'safe_seqid': 'SPy_1392_0', 'tmhmm_inner_loops': [(1, 6), (67, 72), (126, 136), (187, 220), (281, 286), (331, 342), (395, 398)], 'tmhmm_outer_loops': [(30, 43), (94, 102), (160, 163), (244, 257), (307, 310), (366, 374)], 'name': 'SPy_1392 from AE004092', 'seq': 'MEKTKRYIIA....ALRLKK', 'hmmsearch': [], 'loop_extent': 7, 'is_signalp': False, 'details': ['tmhmm(12)'], 'sequence_length': 398, 'signalp_cleave_position': 0, 'tmhmm_helices': [(7, 29), (44, 66), (73, 93), (103, 125), (137, 159), (164, 186), (221, 243), (258, 280), (287, 306), (311, 330), (343, 365), (375, 394)], 'is_lipop': False}, 

'SPy_1379': {'lipop_cleave_position': None, 'category': 'MEMBRANE(non-PSE)', 'safe_seqid': 'SPy_1379_1', 'tmhmm_inner_loops': [(1, 32), (82, 87), (202, 207), (268, 287), (344, 349), (405, 410)], 'tmhmm_outer_loops': [(56, 58), (106, 178), (231, 244), (307, 320), (373, 381), (434, 437)], 'name': 'SPy_1379 from AE004092', 'seq': 'MTIIIMDSNSA....FSYQFYRFILK', 'hmmsearch': [], 'loop_extent': 36, 'is_signalp': False, 'details': ['tmhmm(11)'], 'sequence_length': 437, 'signalp_cleave_position': 69, 'tmhmm_helices': [(33, 55), (59, 81), (88, 105), (179, 201), (208, 230), (245, 267), (288, 306), (321, 343), (350, 372), (382, 404), (411, 433)], 'is_lipop': False}
}
</code></pre>
<h4>Result output</h4>
<p>The output of the program is printed to stdout in tab delimited format. Additionaly, the output is always written as a Comma Separated Values (CSV) file that can be easily imported into spreadsheet packages such as Microsoft Excel. As most users ultimately working with the output of <em>inmembrane</em> are likely to be biologists familiar with using spreadsheets (for better or worse) for further analysis, CSV was chosen since it can be integrated into many users common workflow.
</p>
<p>For those familiar with Python, it is relatively straightforward to modify the text output by changing <code>protocol.protein_output_line</code>, <code>protocol.summary_table</code> and <code>protocol.protein_csv_line</code> (where <em>protocol</em> is one of the protocols in <code>inmembrane/protocols/*.py</code>).
</p>

<h3>The protocol</h3>
<p>One of the abstractions made in <em>inmembrane</em> is to separate the main loop and the plugins so that <em>inmembrane</em> can accommodate multiple workflows or 'protocols' (currently two protocols are implemented, one for Gram+ bacteria <code>gram_pos</code> and one for Gram- bacteria <code>gram_neg</code>). The choice of protocol is taken from the parameters file <code>inmembrane.config</code>. The relevant protocol is stored in a python module with the same name as the protocol in the <code>protocols</code> sub-directory.
</p>
<p>The protocol <strong>must</strong> implement five functions (these are called from within <code>inmembrane/__init__.py</code>):
</p>
<p><code>get_annotations(params)</code> -- takes the params dictionary as input, returns a list of strings being the names of plugins to be run for this analysis (in hindsight, this function is poorly named and may be changed in the future to something like <strong>plugins_to_run</strong> ).
</p>
<p><code>post_process_proteins(params, proteins)</code> -- takes the params dictionary and the <code>proteins</code> data structure and applies any additional business logic to label sequences based on the key-value pairs already added by the plugins (eg, if is_lipop: category = "LIPOPROTEIN(non-PSE)" ).
</p>
<p><code>protein_output_line(seqid, proteins)</code> -- outputs annotations etc for a given seqid found in <code>proteins</code>. This is the function you should modify to change the format of results printed to stdout at the end of the analysis.
</p>
<p><code>protein_csv_line(seqid, proteins)</code> -- equivalent to <code>protein_output_line</code> above, but for the csv file that is written.
</p>
<p><code>summary_table(params, proteins)</code> -- outputs a summary table to stdout with some aggregate statistics for the entire proteome given as input.
</p>
<p>is to add any plugins required (not all are needed, as there are many different possibilities) and send the fasta sequences, as stored in the <code>proteins</code> dictionary, into the plugin to get the desire property from that plugin.
</p>
<p>Once all plugins have been successfully run, the plugin analyses the results of the external programs, and generates the final sub-cellular localisation and then, the 
</p>

<h3>Parameters - load from file/and or input default</h3>
<p>All relevant parameters for an <em>inmembrane</em> analysis can be found in the <code>inmembrane.config</code> file, which is formatted as a Python dictionary. The dictionary is directly read in at the initialization of the program, and stored internally as <code>params</code>. The protocol and plugins all expect <code>params</code> as one of the key parameters in the main function.
</p>

<h3>Plugins</h3>
<p>The interface with external sequence analysis programs or web services are encapsulated within plugins. The way <em>inmembrane</em> detects and uses plugins is straightforward: they are python modules stored in the <code>inmembrane/plugins</code> directory. The name of the module reflects the name of the program or web service and matches the naming used with <code>inmembrane.config</code>. All calls to the plugins are recognized by the module name, which can be called by <code>eval</code> within Python.
</p>
<p>Each plugin <strong>must</strong> implement one function and contain one variable:
</p>
<p><code>annotate(params, proteins)</code> -- this takes the params dictionary and the <code>proteins</code> data structure and adds key value pairs to reflect that results of the analysis. (TODO: For convenience all plugins should return the <code>proteins</code> data structure upon successful execution, however not all plugins currently follow this rule).
</p>
<p><code>annotate</code> may also take other optional keyword arguments (particularly for plugins that interface with web services, it is convenient to include optional <em>url</em> and <em>batchsize</em> parameters, and a <em>force</em> boolean arguments that allows cached output file to be ignored). 
</p>
<p><code>citation</code> -- a module level dictionary of the form:
</p>
<p><code>{'ref':'some citable reference', 'name':'programname version'}</code> (see details below).
</p>
<p>An important element of every plugin is the parsing of the results output by the external analysis program - either text processing of an output file or stdout, handling SOAP responses (via the <code>suds</code> package) or HTML scraping of the web page output (mostly via <code>BeautifulSoup</code>). Given that Python has excellent text-processing facilities, the files are generally parsed in the main <code>annotate</code> function or an auxillary reusable function. The text files are generally sequential table-like output and so a simple iteration of the output lines is in general sufficient to process the output.
</p>
<p>As <em>inmembrane</em> is a glue program that builds on the work of many excellent analysis packages, <em>inmembrane</em> takes care to make sure credit is given. As such citations for each program are considered essential parts of the plugin, and they are stored directly in the source file, and are extracted, and displayed every time the program is run and stored in <code>citations.txt</code>.
</p>

<h3>Logging, temporary output and debugging</h3>
<p>STDERR is used to output status messages as the program executed (eg the currently running plugin, a pseudo-progress bar if we are looping and polling a web service). These status updates should be prefixed by a # character. Most plugins etc also contain a module level variable <code>__DEBUG__</code> which prints additional information useful for debugging to STDERR. The final tab-delimited results and summary table are sent to STDOUT, so standard Unix redirection can be used to capture the two streams seperately if desired (eg <code>inmembrane_scan myseqs.fasta &gt;results.out 2&gt;results.err</code> )
</p>
<p><code>inmembrane</code> always creates a directory caching the output of external analysis packages, named based on the name of the input FASTA file without an extension. The input FASTA file is copied into this directory (as <code>input.fasta</code>), along with <code>citation.txt</code>. Output from each external package is named in the form 'plugin_name.out'.
</p>

          
        </div>
      </div>

      <hr>

      <div class="footer">
        <p>&copy; 2012, Andrew Perry and Bosco Ho</p>
      </div>

    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery.js"></script>
    <script src="js/bootstrap-transition.js"></script>
    <script src="js/bootstrap-alert.js"></script>
    <script src="js/bootstrap-modal.js"></script>
    <script src="js/bootstrap-dropdown.js"></script>
    <script src="js/bootstrap-scrollspy.js"></script>
    <script src="js/bootstrap-tab.js"></script>
    <script src="js/bootstrap-tooltip.js"></script>
    <script src="js/bootstrap-popover.js"></script>
    <script src="js/bootstrap-button.js"></script>
    <script src="js/bootstrap-collapse.js"></script>
    <script src="js/bootstrap-carousel.js"></script>
    <script src="js/bootstrap-typeahead.js"></script>

  </body>
</html>
